import type { RequestFnInfo, XAgent } from './useXAgent'
import { ref, unref } from 'vue'

export type SimpleType = string | number | boolean | object

export type MessageStatus = 'loading' | 'updating' | 'complete' | 'error'

export type MessageRole = 'user' | 'assistant'

type RequestPlaceholderFn<Message extends SimpleType> = (
  message: Message,
  info: { messages: MessageInfo<Message>[] },
) => Message

type RequestFallbackFn<Message extends SimpleType> = (
  message: Message,
  info: { error: Error, messages: MessageInfo<Message>[] },
) => Message | Promise<Message>

export interface XChatConfig<
  AgentMessage extends SimpleType = string,

> {
  agent?: XAgent<AgentMessage>

  defaultMessages?: DefaultMessageInfo<AgentMessage>[]

  getRequestParams?: (messages: MessageInfo<AgentMessage>[]) => RequestFnInfo<AgentMessage>
  requestPlaceholder?: AgentMessage | RequestPlaceholderFn<AgentMessage>
  requestFallback?: AgentMessage | RequestFallbackFn<AgentMessage>
}

export interface MessageInfo<Message extends SimpleType> {
  id: number | string
  message: Message
  role: MessageRole
  status: MessageStatus
}

export type DefaultMessageInfo<Message extends SimpleType> = Pick<MessageInfo<Message>, 'message'> &
  Partial<Omit<MessageInfo<Message>, 'message'>>

export interface RequestResultObject<Message> {
  message: Message | Message[]
  status: MessageStatus
}

export type RequestResult<Message extends SimpleType> =
  | Message
  | Message[]
  | RequestResultObject<Message>
  | RequestResultObject<Message>[]

export type StandardRequestResult<Message extends SimpleType> = Omit<
  RequestResultObject<Message>,
  'message' | 'status'
> & {
  message: Message
  status?: MessageStatus
}

export default function useXChat<
  AgentMessage extends SimpleType = string,
>(config: XChatConfig<AgentMessage>) {
  const { defaultMessages, agent, requestFallback, requestPlaceholder, getRequestParams: customGetRequestParams } = config

  const idRef = ref(0)
  const createMessage = (role: MessageRole, status: MessageStatus, message: AgentMessage, extraInfo: Partial<MessageInfo<AgentMessage>> = {}) => {
    const msg: MessageInfo<AgentMessage> = {
      id: `msg_${idRef.value}`,
      message,
      role,
      status,
      ...extraInfo,
    }

    idRef.value += 1

    return msg
  }

  // @ts-expect-error: TODO
  const messages: Ref<MessageInfo<AgentMessage>[]> = ref((defaultMessages || []).map(info => createMessage('user', 'complete', info.message)))
  const setMessages = (setter: (messages: MessageInfo<AgentMessage>[]) => MessageInfo<AgentMessage>[]) => {
    messages.value = setter(unref(messages))
  }
  const getMessages = (): MessageInfo<AgentMessage>[] => messages.value

  const getFilteredMessages = (msgs: MessageInfo<AgentMessage>[]) =>
    msgs
      .filter(info => info.status !== 'loading' && info.status !== 'error')

  const getRequestMessages = () => getFilteredMessages(getMessages())
  const getRequestParams = () => {
    return {
      messages: getRequestMessages().map(i => ({
        role: i.role,
        content: i.message,
      })),
    } as RequestFnInfo<AgentMessage>
  }

  const onRequest = (message: AgentMessage) => {
    if (!agent) {
      throw new Error(
        'The agent parameter is required when using the onRequest method in an agent generated by useXAgent.',
      )
    }

    let loadingMsgId: number | string | null = null

    // Add placeholder message
    setMessages((ori) => {
      let nextMessages = [...ori, createMessage('user', 'complete', message)]

      if (requestPlaceholder) {
        let placeholderMsg: AgentMessage

        if (typeof requestPlaceholder === 'function') {
          // typescript has bug that not get real return type when use `typeof function` check
          placeholderMsg = (requestPlaceholder as RequestPlaceholderFn<AgentMessage>)(message, {
            messages: getFilteredMessages(nextMessages),
          })
        }
        else {
          placeholderMsg = requestPlaceholder
        }

        const loadingMsg = createMessage('assistant', 'loading', placeholderMsg)
        loadingMsgId = loadingMsg.id

        nextMessages = [...nextMessages, loadingMsg]
      }

      return nextMessages
    })

    // Request
    let updatingMsgId: number | string | null = null
    const updateMessage = (message: AgentMessage) => {
      let msg = getMessages().find(info => info.id === updatingMsgId)

      if (!msg) {
        // Create if not exist
        msg = createMessage('assistant', 'updating', message)
        setMessages((ori) => {
          const oriWithoutPending = ori.filter(info => info.id !== loadingMsgId)
          return [...oriWithoutPending, msg!]
        })
        updatingMsgId = msg.id
        loadingMsgId = null
      }
      else {
        // Update directly
        setMessages((ori) => {
          return ori.map((info) => {
            if (info.id === updatingMsgId) {
              return {
                ...info,
                message,
                status: 'updating',
              }
            }
            return info
          })
        })
      }

      return msg
    }

    agent.request(
      customGetRequestParams ? customGetRequestParams(getRequestMessages()) : getRequestParams(),
      {
        onUpdate: (message) => {
          updateMessage(message)
        },
        onSuccess: (message) => {
          const msgId = updatingMsgId || loadingMsgId
          const msg = getMessages().find(info => info.id === msgId)

          if (msg) {
            msg.status = 'complete'
            msg.message = message
          }
        },
        onError: async (error: Error) => {
          if (requestFallback) {
            let fallbackMsg: AgentMessage

            // Update as error
            if (typeof requestFallback === 'function') {
              // typescript has bug that not get real return type when use `typeof function` check
              fallbackMsg = await (requestFallback as RequestFallbackFn<AgentMessage>)(message, {
                error,
                messages: getRequestMessages(),
              })
            }
            else {
              fallbackMsg = requestFallback
            }

            setMessages(ori => [
              ...ori.filter(info => info.id !== loadingMsgId && info.id !== updatingMsgId),
              createMessage('assistant', 'error', fallbackMsg),
            ])
          }
          else {
            // Remove directly
            setMessages((ori) => {
              return ori.filter(info => info.id !== loadingMsgId && info.id !== updatingMsgId)
            })
          }
        },
      },
    )
  }

  return {
    onRequest,
    messages,
    setMessages,
  } as const
}
